<!DOCTYPE html>
<html>
<head>
<title>Nekonečné Plátno</title>
<style>
  body { margin: 0; overflow: hidden; background-color: #f0f0f0; }
  canvas { display: block; }
</style>
</head>
<body>
  <canvas id="infiniteCanvas"></canvas>
  <script>
    const canvas = document.getElementById('infiniteCanvas');
    const ctx = canvas.getContext('2d');

    let cameraX = 0;
    let cameraY = 0;
    let cameraZoom = 1;

    // Ukázkové objekty k vykreslení (s virtuálními souřadnicemi)
    const objects = [
      { x: 50,  y: 50,  width: 30, height: 30, color: 'red' },
      { x: 200, y: 150, width: 50, height: 50, color: 'blue' },
      { x: -100,y: -80, width: 40, height: 40, color: 'green' },
      // ... přidej více objektů
    ];

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      draw(); // Překresli po změně velikosti
    }

    function draw() {
      // Vymaž canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Uložení aktuálního stavu kontextu (důležité)
      ctx.save();

      // 1. Posun na střed canvasu (aby (0,0) virtuálního světa bylo uprostřed)
      ctx.translate(canvas.width / 2, canvas.height / 2);
      // 2. Aplikuj zoom
      ctx.scale(cameraZoom, cameraZoom);
      // 3. Aplikuj posun kamery (pozor na znaménko, posouváme svět "pod" kamerou)
      ctx.translate(-cameraX, -cameraY);

      // Vykresli objekty
      objects.forEach(obj => {
        // ZÁKLADNÍ VIEWPORT CULLING (velmi zjednodušený)
        // Kontroluje, zda je objekt alespoň částečně viditelný
        // (x, y) objektu jsou ve virtuálních souřadnicích
        // Převod hranic viewportu do virtuálních souřadnic
        const viewLeft = cameraX - (canvas.width / 2) / cameraZoom;
        const viewRight = cameraX + (canvas.width / 2) / cameraZoom;
        const viewTop = cameraY - (canvas.height / 2) / cameraZoom;
        const viewBottom = cameraY + (canvas.height / 2) / cameraZoom;

        if (obj.x + obj.width > viewLeft &&
            obj.x < viewRight &&
            obj.y + obj.height > viewTop &&
            obj.y < viewBottom) {
          ctx.fillStyle = obj.color;
          ctx.fillRect(obj.x, obj.y, obj.width, obj.height);
        }
      });

      // Vykresli mřížku pro orientaci (volitelné)
      drawGrid();

      // Obnovení původního stavu kontextu
      ctx.restore();

      requestAnimationFrame(draw); // Smyčka animace
    }

    function drawGrid() {
      const gridSize = 50; // Velikost buňky mřížky ve virtuálních jednotkách
      ctx.strokeStyle = 'rgba(0,0,0,0.1)';
      ctx.lineWidth = 1 / cameraZoom; // Aby čáry byly stále tenké při zoomu

      const startX = Math.floor((cameraX - (canvas.width / 2) / cameraZoom) / gridSize) * gridSize;
      const endX = Math.ceil((cameraX + (canvas.width / 2) / cameraZoom) / gridSize) * gridSize;
      const startY = Math.floor((cameraY - (canvas.height / 2) / cameraZoom) / gridSize) * gridSize;
      const endY = Math.ceil((cameraY + (canvas.height / 2) / cameraZoom) / gridSize) * gridSize;

      for (let x = startX; x <= endX; x += gridSize) {
        ctx.beginPath();
        ctx.moveTo(x, startY - gridSize); // Trochu přesah pro jistotu
        ctx.lineTo(x, endY + gridSize);
        ctx.stroke();
      }
      for (let y = startY; y <= endY; y += gridSize) {
        ctx.beginPath();
        ctx.moveTo(startX - gridSize, y);
        ctx.lineTo(endX + gridSize, y);
        ctx.stroke();
      }
    }

    // Ovládání myší
    let isDragging = false;
    let lastMouseX, lastMouseY;

    canvas.addEventListener('mousedown', (e) => {
      isDragging = true;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
    });

    canvas.addEventListener('mousemove', (e) => {
      if (!isDragging) return;
      const dx = (e.clientX - lastMouseX) / cameraZoom; // Přepočet na virtuální posun
      const dy = (e.clientY - lastMouseY) / cameraZoom;
      cameraX -= dx;
      cameraY -= dy;
      lastMouseX = e.clientX;
      lastMouseY = e.clientY;
      // Není třeba volat draw() zde, requestAnimationFrame to zařídí
    });

    canvas.addEventListener('mouseup', () => {
      isDragging = false;
    });

    canvas.addEventListener('mouseleave', () => { // Pro případ, že myš opustí canvas při tažení
      isDragging = false;
    });

    canvas.addEventListener('wheel', (e) => {
      e.preventDefault(); // Zabraň scrollu stránky
      const zoomIntensity = 0.1;
      const wheel = e.deltaY < 0 ? 1 : -1; // Směr kolečka
      const zoomFactor = Math.exp(wheel * zoomIntensity);

      // Zoom směrem ke kurzoru myši
      const mouseX = e.clientX - canvas.width / 2;  // Pozice myši relativně ke středu canvasu
      const mouseY = e.clientY - canvas.height / 2;

      // Kolik z virtuálního světa "přidáme" nebo "ubereme" pod kurzorem
      cameraX += mouseX / cameraZoom - mouseX / (cameraZoom * zoomFactor);
      cameraY += mouseY / cameraZoom - mouseY / (cameraZoom * zoomFactor);

      cameraZoom *= zoomFactor;
      // Omezení zoomu (volitelné)
      cameraZoom = Math.max(0.1, Math.min(cameraZoom, 10));
      // Není třeba volat draw() zde
    });

    // Inicializace
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas(); // Nastaví počáteční velikost a spustí kreslení
  </script>
</body>
</html>